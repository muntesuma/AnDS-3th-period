#include <stdio.h>
#include <string.h>
#include <iostream>
using namespace std;

class String {
	char *str;
	int len;

	public:
		String(int l = 0) { 		        // Конструктор по умолчанию		
	// В С++ в случае задания некоторого стандартного значения необязательно каждый раз задавать фактические аргументы (компилятор подставит их автоматически)
        		str = new char[l + 1]; 		// Выделение динамической памяти
        		len = 0;
        		strcpy(str, "\0"); 			// Копирование конца строки в str
    		};

    		String(const char *a) { 			// Конструктор строки
        		str = new char[strlen(a) + 1]; // Выделение динамической памяти + 1 (для нулевого кода)
        		strcpy(str, a);
        		len = strlen(a);
    		};

    		String(String &a) {				// Конструктор копирования 
        		str = new char[a.len + 1];
        		len = a.len;
        		strcpy(str, a.str);
    		};

    		~String() {						// Деструктор для освобождения динамической памяти (занимаемой член-данными класса) при выходе из функций
        		if (str) delete[]str;
        		str = NULL;
    		} 

    		int Len();						// Функция возвращения длинны строки

    		String &operator=(const String &); 	// Оператор присваивания

    		char &operator[](int);				// Оператор проверки корректности заданной подстроки

    		bool operator==(String &); 			// Оператор проверки равенства
    		bool operator!=(String &); 			// Оператор проверки неравенства

    		String operator+(const String &);		// Оператор сложения строк
    		String &operator+=(const String &);		// Оператор добавления строки

    		friend istream &operator>>(istream &, String &);   	// Внешняя по отношению к классу функция, Член-функция известного на данный момент другого класса
																// Другой определенный (или объявленный) на данный момент класс

    		friend ostream &operator<<(ostream &, String &);	// Первым операндом операции << является поток вывода
    															// Поэтому ее можно перегрузить для абстрактных типов только, как дружественную классу
    
    		// Если необходимо разрешить внешней функции использовать член-данные из части private какого-либо класса, ее можно объявить дружественной этому классу

    		int BMH_search(String &); 			// Функция бм-поиска
};

int String::Len() { // Функция возвращения длинны строки
    	return len;
}
// Формальный аргумент - ссылка на фактический, фактический и формальный аргумент – имя одной и той же ячейки.
// При изменении формального аргумента всегда будет меняться и фактический.
// Формальный аргумент просто становится другим именем фактического. 
// Для того, чтобы иметь возможность менять значения фактических аргументов

String &String::operator=(const String &a) {  	// Оператор присваивания
												// При использовании динамической памяти в классе, операция ‘=’ обязательно будет перегружается
    	if (this != &a) {						// В случае присвоения s = s
        	delete[] str;   					// Освобождение динамической памяти      
        	str = new char[a.len + 1];  		// Определение поля len
        	strcpy(str, a.str);
        	len = a.len;
    	}
    	return *this; 					// При вызове функции объектом, в функцию передается неявный указатель на объект. Его можно задать и явно с помощью ключевого слова this
										// * - операция разадресации- возвращает значение переменной, хранящееся по адрессу  
										// & - определение адреса(адресация), присваевает адрес переменной а
}

char &String::operator[](int a) {			// Оператор проверки корректности заданной подстроки	
    	if (a < 0 || a >= len) exit(1);
    	return str[a];
}

bool String::operator==(String &a) {		// Оператор проверки равенства
    	if (strcmp(str, a.str)) return false; 	// strcmp ищет несхожести
    	return true;
}

bool String::operator!=(String &a) {		// Оператор проверки неравенства
    	if (strcmp(str, a.str)) return true;
    	return false;
}

String String::operator+(const String &a) { 	// Оператор сложения строк
   	String z(len + a.len + 1);			// Определение пустой локальной строки суммарной длины
    	z.len = len + a.len;				// Определение длинны результата
    	strcpy(z.str, str);				// Запись строки первого операнда
    	strcat(z.str, a.str); 				// Добавление строки второго операнда
    	return z; 						// Работает конструктор копирования результата
								// Деструктор разрушает локальный объект z, невозможно вернуть ссылку на локальный объект
} 

String &String::operator+=(const String &a) {   // Оператор добавления
    	char *t = new char[len + 1];
    	strcpy(t, str); 					// Временное сохранение 1-ого операнда
    	delete[] str; 
	len = len + a.len; 				// Задание новой длинны
    	str = new char[len + 1];
    	strcpy(str, t);
    	strcat(str, a.str);
    	delete[] t;
    	return *this;
}
// Значение фактического аргумента присваивается формальному. При этом значение фактического аргумента никогда не может измениться
// При передаче параметров по ссылке передается ссылка на объект, через которую мы можем манипулировать самим объектов, а не просто его значением

istream &operator>>(istream &in, String &a) {	// Для операции ввода >> аргумент должен иметь тип & (ссылка) 
	char tmp[100];					// Иначе значение фактического аргумента не изменится (не введется)
    	in >> tmp;
    	String q(tmp);
    	a = q;
    	return in;
}

ostream &operator<<(ostream &out, String &a) { // Для аргумента операции вывода << тип & желателен (чтобы не выполнялось копирование), но не обязателен
    	cout << a.str;
    	return out;
}

int String::BMH_search(String &a) { 	// Функция БМ-поиска
    	int m = a.len;				// Длинна образца
    	int n=len;					// Длинна текста
    	int t[256];					// Выделение памяти под таблицу символов
    	fill_n(t, 256, m);			// Заполнение элементов таблицы символов длинной образца

    	for (int i = 0; i < m - 1; i++) {  	// Замена значения встречающихся в образце элементов
        	t[(int)a.str[i]] = m-1-i;     // Для быстрого получения велечины сдвига 
    	}

    	int i = m-1, j = m-1;

    	while (i < n && j>=0) {
        	int k = i;
        	j = m-1;
        	while (j>=0) {
            	if(str[k]!=a.str[j]) {
                		i += t[str[i]];
                		j = m - 1;
                		break;
            	}
            	j--;
            	k--;
        	}
    	}

    	if(j >= 0) return -1;
    	else return i+1-m;
}


int main() {						// Основная функция
	setlocale(LC_ALL, "Russian");			// Подключение русского языка (для удобства)

    	String a, b("Foot");
    	String c("ball");

    	a = b + c;   					// Демонстрация работоспособности перегруженной операции +
    	cout << a << endl;

    	a += c;        					// Демонстрация работоспособности перегруженной операции +=
    	cout << a << endl;

	    b = "ball";
    	if(c == b) cout << "с и b равны\n"; 	// Демонстрация работоспособности перегруженной операции == (c = cool & b = cool)
    	
	    b = a;
    	if(c != b) cout << "с и b не равны \n"; 	// Демонстрация работоспособности перегруженной операции != (c = cool & a = pokemoncool)


    	a = "Vo dvore trava na trave drova";
    	b = "drova";
    	cout << "Первое вхождение образца = " << a.BMH_search(b) << endl << "Текст = " << a << "\nОбразец = " << b << endl; // Демонстрация работоспособности бм-поиска 

    	String h;
    	cin >> h;
    	cout << "Длинна = " << h.Len(); 		// Демонстрация работоспособности функции подсчёта длины

    	return 0;
}